Здравствуйте.
Лазарев Арсений, 6 группа, 2 курс.
Второй вариант
1) Что такое ООП?
Объектно-ориентированное программирование (ООП) — это парадигма программирования, в которой основными концептуальными единицами являются объекты, объединяющие в себе данные (поля, свойства, атрибуты) и методы (функции, процедуры) для работы с этими данными. ООП моделирует предметную область как совокупность взаимодействующих объектов.
Ключевые принципы ООП:
1. Инкапсуляция: Сокрытие внутреннего состояния объекта и деталей его реализации от внешнего вмешательства. Доступ к данным осуществляется только через публичные методы (геттеры, сеттеры), что обеспечивает контроль над целостностью объекта.
2. Наследование: Способность одного класса (потомка, дочернего класса) наследовать свойства и методы другого класса (родителя, базового класса). Это позволяет создавать иерархии классов, повторно использовать код и логически организовывать структуру программы.
3. Полиморфизм: Возможность объектов с одинаковой спецификацией (интерфейсом) иметь различную реализацию. Это позволяет использовать один и тот же интерфейс для работы с разными типами объектов.
4. Абстракция: Процесс выделения существенных характеристик системы и игнорирования нерелевантных деталей. В ООП абстракция реализуется через абстрактные классы и интерфейсы, которые определяют что должен делать объект, но не как он это делает.

3) Архитектура ПО
Архитектура программного обеспечения — это фундаментальная организация системы, воплощенная в её компонентах, их отношениях друг к другу и к окружению, а также принципы, определяющие проектирование и развитие системы. 
1. Многослойная архитектура (Layered Architecture)
Этот подход работает по принципу разделения ответственностей. ПО разделено на слои, лежащие друг на друге, и каждый из них выполняет определенную обязанность.
2.Многоуровневая архитектура (Tiered Architecture)
Этот архитектурный подход разделяет комплекс ПО на уровни по принципу взаимодействия “клиент-сервер”. Архитектура может иметь один, два и больше уровней, разделяющих ответственности между поставщиком данных и потребителем.
3. Сервис-ориентированная архитектура (Service Oriented Architecture — SOA)
Эта архитектурная модель состоит из компонентов и приложений, которые связываются друг с другом с помощью четко определенных сервисов.
Она состоит из 5 элементов:
сервисы (Services);
сервисная шина (Service Bus);
сервисный репозиторий (Service Repository catalogue of services);
безопасность SOA (SOA Security);
управление SOA (SOA Governance).
4.Микросервисная архитектура (Microservice Architecture)
При таком подходе приложение разрабатывается как набор небольших сервисов, каждый из которых работает в собственном процессе и связывается с легковесными механизмами, обычно API для HTTP-ресурса.

4)Энтропия ПО
Энтропия по Хакену
 1. Система должна! быть открытой
 2. Закрытая система придет к состоянию с максимальной 
энтропией и прекратить любые эволюции
 3. Открытая система должна быть далека от равновесия
 4. В точке равновесия система не способна к самоорганизации
 5. Флуктуации
 6. Бифуркации
 7. Наличие отрицательных обратных связей, обеспечивающих 
сохранение структуры и близкого к равновесию состояния
 8. Преобладание положительных обратных связей над 
отрицательными
 9. Стрела времени
Примеры:
1. "Раздувание" классов и методов (Code Bloat): Изначально простой и понятный класс User со временем обрастает десятками методов, которые лишь частично относятся к его прямой ответственности. Он начинает отвечать и за отправку email, и за валидацию данных формы, и за генерацию отчетов. Внутри методов появляются гигантские блоки if-else, которые сложно понять и изменить. Это увеличивает энтропию.
2. Жёсткие связи (Tight Coupling): Изначально модульная система со временем обрастает неявными зависимостями. Класс Order начинает напрямую создавать экземпляры класса DatabaseConnection и EmailSender, вместо того чтобы получать их извне (через Dependency Injection). Из-за этого изменение в одном модуле вызывает "эффект домино" и требует изменений в десятках других мест. Система становится хрупкой.
3. Дублирование кода (Copy-Paste Programming): Разработчики, не находя или не понимая, как использовать существующий код, копируют логику из одного места в другое. Со временем в коде появляются 10 одинаковых функций calculateDiscount, но с небольшими различиями. При необходимости исправить алгоритм расчёта, приходится вносить изменения в 10 мест, что почти гарантированно приведёт к ошибкам. Это классический пример роста энтропии.

5)Закон Иерархических Компенсаций Седова в контексте АйТи
Евгений Александрович Седов
Советский ученый, инженер, практик, изобретатель, педагог, популяризатор науки.
Автор доклада "Информационно-энтропийные свойства социальных систем" в которой описал Закон Иерархических Компенсаций (текст для доклада был подготовлен учёным за 2 дня до его смерти).
В докладе автор вывел магическое соотношение  80% детерминированности: языковая структура20% хаоса: вариабельность, “мутации”, “новости”, ради которых и пишется текст.
При увеличении детерминированности теряется адаптивность, и система разрушится при изменении внешних условий.
Единственный выход: разрушение и создание новой системы.
Закон Иерархических Компенсаций: Разнообразие на верхних уровнях иерархии может быть обеспечено только за счет ограничения разнообразия на нижних уровнях. Сложные системы можно строить только из ограниченного числа простых или Стандартизация неизбежна!
Если точнее: Закон Седова
 1. Действительный рост разнообразия на высшем уровне 
обеспечивается его эффективным ограничением на 
предыдущих уровнях. Закон иерархической компенсации (закон 
Седова), охватывающий живую и неживую природу, язык, 
культуру, все сферы социального управления, существенно 
дополняет классический закон необходимого разнообразия 
Эшби.
 2. Только при условии ОГРАНИЧЕНИЯ РАЗНООБРАЗИЯ 
нижележащего уровня можно формировать разнообразные 
функции и структуры находящихся на более высоких уровнях 
систем, таким образом, возникает проблема поисков 
оптимального соотношения детерминации и непредсказуемости 
составных частей и и системы в целом.
Закон Седова
 3. В структурном смысле закон означает, что «отсутствие 
ограничений приводит к деструктурализации системы как 
целого, что приводит к общей диверсификации системы в 
контексте объемлющей её среды.
Закон Седова
 4. Существует взаимосвязь второго начала термодинамики с 
негэнтропийным принципом информации, установленным 
Бриллюэном: накопление информации (отрицательной 
энтропии) внутри какой-либо системы всегда оплачивается 
возрастанием энтропии внешней среды

Примеры в контексте IT:
1. Компиляторы vs Интерпретаторы:
Упрощение на уровне разработчика: Языки высокого уровня (Python, JavaScript) очень просты для чтения и написания (упрощение).
Компенсация на уровне исполнения: Это компенсируется огромной сложностью компиляторов, интерпретаторов и виртуальных машин (JVM, V8), которые преобразуют простой для человека код в машинные инструкции.
2. Базы данных (SQL):
Упрощение на уровне прикладного программиста: Язык SQL позволяет одной декларативной командой (SELECT ... WHERE ... JOIN) выполнить сложную операцию с данными. Программисту не нужно думать о том, как physically прочитать данные с диска.
Компенсация на уровне СУБД: Вся сложность (оптимизация запросов, управление индексами, кэширование, транзакции, ACID) ложится на систему управления базами данных (PostgreSQL, Oracle).
3. Облачные платформы (AWS, Azure, GCP):
Упрощение на уровне инфраструктуры: Разработчик может арендовать виртуальную машину, базу данных или бессерверную функцию в несколько кликов, не покупая железо и не настраивая сети (упрощение).
Компенсация на уровне облачного провайдера: За этим стоит невероятно сложная система дата-центров, систем охлаждения, сетевого оборудования, программного обеспечения для оркестрации (Kubernetes) и виртуализации.
4. Фреймворки (Spring, React, Django):
Упрощение на уровне бизнес-логики: Разработчик использует аннотации @Autowired или хуки useState, чтобы быстро решать прикладные задачи, не задумываясь о создании объектов или отслеживании состояния DOM.
Компенсация на уровне фреймворка: Сами фреймворки — это монументальные, сложные проекты, которые берут на себя управление жизненным циклом, dependency injection, рендеринг и т.д.
5. Контейнеризация (Docker):
Упрощение на уровне деплоя: "Оно работает на моей машине". Контейнеры решают эту проблему, упаковывая приложение со всеми зависимостями в переносимый образ (упрощение деплоя и зависимостей).
Компенсация на уровне оркестрации: Появляется сложность управления сотнями контейнеров: их запуск, масштабирование, сетевые взаимодействия, обнаружение сервисов. Эту сложность берут на себя системы оркестрации, в первую очередь — Kubernetes.
6. Процессоры:
Упрощение на уровне программиста: Программист пишет линейный код. Ему не нужно думать о параллельном выполнении инструкций на аппаратном уровне.
Компенсация на уровне процессора: Современные CPU — это невероятно сложные устройства с конвейерной обработкой, суперскалярностью, спекулятивным выполнением, несколькими уровнями кэша, которые пытаются предугадать, какие инструкции понадобятся next, чтобы выполнить линейный код максимально параллельно и быстро.
7.API и Микросервисы:
Упрощение на уровне команд и сервисов: Каждая команда может разрабатывать свой микросервис независимо, используя свои технологии и релизный цикл (упрощение организации работы).
Компенсация на уровне взаимодействия и мониторинга: Резко возрастает сложность обеспечения связи между сервисами (API Gateway, Service Mesh), отслеживания транзакций, которые проходят через десятки сервисов (Distributed Tracing), и управления распределёнными данными (Eventual Consistency).

2) Процедурная - Структурная декомпозиция
Процедурная декомпозиция — это метод проектирования программы в парадигме процедурного программирования, при котором сложная задача последовательно разбивается на иерархию более простых, функционально самостоятельных подзадач, оформляемых в виде процедур (функций). Процедуры верхнего уровня управляют логикой выполнения, вызывая процедуры более низкого уровня, которые реализуют конкретные операции.
Структурная декомпозиция — более общее понятие, описывающее принцип разбиения сложной системы на составные части (модули, компоненты, подсистемы) с четко определенными связями между ними. В контексте программирования структурная декомпозиция может применяться не только к алгоритмам, но и к данным, архитектуре системы, интерфейсам.
Примеры структурной декомпозиции:
Декомпозиция данных: Разбиение базы данных на таблицы, связей между ними, нормализация
Декомпозиция системы: Разделение приложения на слои (presentation, business, data layers)
Декомпозиция интерфейса: Разбиение пользовательского интерфейса на компоненты (header, sidebar, main content, footer)
Примеры процедурной декомпозиции (точечный пример):
Программа "Калькулятор":
Верхний уровень: main() — управляет основным потоком
Второй уровень: функции add(), subtract(), multiply(), divide()
Низкий уровень: внутри divide() — функция validateDenominator()